// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: loans.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const countLoans = `-- name: CountLoans :one
SELECT COUNT(*) FROM loans
`

func (q *Queries) CountLoans(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLoans)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLoansByStatus = `-- name: CountLoansByStatus :one
SELECT COUNT(*) FROM loans WHERE status = $1
`

func (q *Queries) CountLoansByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLoansByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLoansByUser = `-- name: CountLoansByUser :one
SELECT COUNT(*) FROM loans WHERE user_id = $1
`

func (q *Queries) CountLoansByUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLoansByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLoansByUserAndStatus = `-- name: CountLoansByUserAndStatus :one
SELECT COUNT(*) FROM loans WHERE user_id = $1 AND status = $2
`

type CountLoansByUserAndStatusParams struct {
	UserID uuid.UUID `json:"user_id"`
	Status string    `json:"status"`
}

func (q *Queries) CountLoansByUserAndStatus(ctx context.Context, arg CountLoansByUserAndStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLoansByUserAndStatus, arg.UserID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLoan = `-- name: CreateLoan :one
INSERT INTO loans (id, user_id, book_id, borrowed_at, due_date, returned_at, status)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, book_id, borrowed_at, due_date, returned_at, status
`

type CreateLoanParams struct {
	ID         uuid.UUID    `json:"id"`
	UserID     uuid.UUID    `json:"user_id"`
	BookID     uuid.UUID    `json:"book_id"`
	BorrowedAt time.Time    `json:"borrowed_at"`
	DueDate    time.Time    `json:"due_date"`
	ReturnedAt sql.NullTime `json:"returned_at"`
	Status     string       `json:"status"`
}

func (q *Queries) CreateLoan(ctx context.Context, arg CreateLoanParams) (Loan, error) {
	row := q.db.QueryRowContext(ctx, createLoan,
		arg.ID,
		arg.UserID,
		arg.BookID,
		arg.BorrowedAt,
		arg.DueDate,
		arg.ReturnedAt,
		arg.Status,
	)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BookID,
		&i.BorrowedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.Status,
	)
	return i, err
}

const getActiveByUserAndBook = `-- name: GetActiveByUserAndBook :one
SELECT id, user_id, book_id, borrowed_at, due_date, returned_at, status FROM loans
WHERE user_id = $1 AND book_id = $2 AND status = 'active'
`

type GetActiveByUserAndBookParams struct {
	UserID uuid.UUID `json:"user_id"`
	BookID uuid.UUID `json:"book_id"`
}

func (q *Queries) GetActiveByUserAndBook(ctx context.Context, arg GetActiveByUserAndBookParams) (Loan, error) {
	row := q.db.QueryRowContext(ctx, getActiveByUserAndBook, arg.UserID, arg.BookID)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BookID,
		&i.BorrowedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.Status,
	)
	return i, err
}

const getLoanByID = `-- name: GetLoanByID :one
SELECT id, user_id, book_id, borrowed_at, due_date, returned_at, status FROM loans WHERE id = $1
`

func (q *Queries) GetLoanByID(ctx context.Context, id uuid.UUID) (Loan, error) {
	row := q.db.QueryRowContext(ctx, getLoanByID, id)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BookID,
		&i.BorrowedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.Status,
	)
	return i, err
}

const getLoanByIDWithDetails = `-- name: GetLoanByIDWithDetails :one
SELECT
    l.id, l.user_id, l.book_id, l.borrowed_at, l.due_date, l.returned_at, l.status,
    u.name as user_name,
    b.title as book_title
FROM loans l
JOIN users u ON l.user_id = u.id
JOIN books b ON l.book_id = b.id
WHERE l.id = $1
`

type GetLoanByIDWithDetailsRow struct {
	ID         uuid.UUID    `json:"id"`
	UserID     uuid.UUID    `json:"user_id"`
	BookID     uuid.UUID    `json:"book_id"`
	BorrowedAt time.Time    `json:"borrowed_at"`
	DueDate    time.Time    `json:"due_date"`
	ReturnedAt sql.NullTime `json:"returned_at"`
	Status     string       `json:"status"`
	UserName   string       `json:"user_name"`
	BookTitle  string       `json:"book_title"`
}

func (q *Queries) GetLoanByIDWithDetails(ctx context.Context, id uuid.UUID) (GetLoanByIDWithDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getLoanByIDWithDetails, id)
	var i GetLoanByIDWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BookID,
		&i.BorrowedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.Status,
		&i.UserName,
		&i.BookTitle,
	)
	return i, err
}

const listLoans = `-- name: ListLoans :many
SELECT id, user_id, book_id, borrowed_at, due_date, returned_at, status FROM loans
ORDER BY borrowed_at DESC
LIMIT $1 OFFSET $2
`

type ListLoansParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListLoans(ctx context.Context, arg ListLoansParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listLoans, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Loan{}
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByStatus = `-- name: ListLoansByStatus :many
SELECT id, user_id, book_id, borrowed_at, due_date, returned_at, status FROM loans
WHERE status = $1
ORDER BY borrowed_at DESC
LIMIT $2 OFFSET $3
`

type ListLoansByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListLoansByStatus(ctx context.Context, arg ListLoansByStatusParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listLoansByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Loan{}
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByStatusWithDetails = `-- name: ListLoansByStatusWithDetails :many
SELECT
    l.id, l.user_id, l.book_id, l.borrowed_at, l.due_date, l.returned_at, l.status,
    u.name as user_name,
    b.title as book_title
FROM loans l
JOIN users u ON l.user_id = u.id
JOIN books b ON l.book_id = b.id
WHERE l.status = $1
ORDER BY l.borrowed_at DESC
LIMIT $2 OFFSET $3
`

type ListLoansByStatusWithDetailsParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListLoansByStatusWithDetailsRow struct {
	ID         uuid.UUID    `json:"id"`
	UserID     uuid.UUID    `json:"user_id"`
	BookID     uuid.UUID    `json:"book_id"`
	BorrowedAt time.Time    `json:"borrowed_at"`
	DueDate    time.Time    `json:"due_date"`
	ReturnedAt sql.NullTime `json:"returned_at"`
	Status     string       `json:"status"`
	UserName   string       `json:"user_name"`
	BookTitle  string       `json:"book_title"`
}

func (q *Queries) ListLoansByStatusWithDetails(ctx context.Context, arg ListLoansByStatusWithDetailsParams) ([]ListLoansByStatusWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listLoansByStatusWithDetails, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLoansByStatusWithDetailsRow{}
	for rows.Next() {
		var i ListLoansByStatusWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Status,
			&i.UserName,
			&i.BookTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByUser = `-- name: ListLoansByUser :many
SELECT id, user_id, book_id, borrowed_at, due_date, returned_at, status FROM loans
WHERE user_id = $1
ORDER BY borrowed_at DESC
LIMIT $2 OFFSET $3
`

type ListLoansByUserParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListLoansByUser(ctx context.Context, arg ListLoansByUserParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listLoansByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Loan{}
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByUserAndStatus = `-- name: ListLoansByUserAndStatus :many
SELECT id, user_id, book_id, borrowed_at, due_date, returned_at, status FROM loans
WHERE user_id = $1 AND status = $2
ORDER BY borrowed_at DESC
LIMIT $3 OFFSET $4
`

type ListLoansByUserAndStatusParams struct {
	UserID uuid.UUID `json:"user_id"`
	Status string    `json:"status"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListLoansByUserAndStatus(ctx context.Context, arg ListLoansByUserAndStatusParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listLoansByUserAndStatus,
		arg.UserID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Loan{}
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByUserAndStatusWithDetails = `-- name: ListLoansByUserAndStatusWithDetails :many
SELECT
    l.id, l.user_id, l.book_id, l.borrowed_at, l.due_date, l.returned_at, l.status,
    u.name as user_name,
    b.title as book_title
FROM loans l
JOIN users u ON l.user_id = u.id
JOIN books b ON l.book_id = b.id
WHERE l.user_id = $1 AND l.status = $2
ORDER BY l.borrowed_at DESC
LIMIT $3 OFFSET $4
`

type ListLoansByUserAndStatusWithDetailsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Status string    `json:"status"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListLoansByUserAndStatusWithDetailsRow struct {
	ID         uuid.UUID    `json:"id"`
	UserID     uuid.UUID    `json:"user_id"`
	BookID     uuid.UUID    `json:"book_id"`
	BorrowedAt time.Time    `json:"borrowed_at"`
	DueDate    time.Time    `json:"due_date"`
	ReturnedAt sql.NullTime `json:"returned_at"`
	Status     string       `json:"status"`
	UserName   string       `json:"user_name"`
	BookTitle  string       `json:"book_title"`
}

func (q *Queries) ListLoansByUserAndStatusWithDetails(ctx context.Context, arg ListLoansByUserAndStatusWithDetailsParams) ([]ListLoansByUserAndStatusWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listLoansByUserAndStatusWithDetails,
		arg.UserID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLoansByUserAndStatusWithDetailsRow{}
	for rows.Next() {
		var i ListLoansByUserAndStatusWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Status,
			&i.UserName,
			&i.BookTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByUserWithDetails = `-- name: ListLoansByUserWithDetails :many
SELECT
    l.id, l.user_id, l.book_id, l.borrowed_at, l.due_date, l.returned_at, l.status,
    u.name as user_name,
    b.title as book_title
FROM loans l
JOIN users u ON l.user_id = u.id
JOIN books b ON l.book_id = b.id
WHERE l.user_id = $1
ORDER BY l.borrowed_at DESC
LIMIT $2 OFFSET $3
`

type ListLoansByUserWithDetailsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type ListLoansByUserWithDetailsRow struct {
	ID         uuid.UUID    `json:"id"`
	UserID     uuid.UUID    `json:"user_id"`
	BookID     uuid.UUID    `json:"book_id"`
	BorrowedAt time.Time    `json:"borrowed_at"`
	DueDate    time.Time    `json:"due_date"`
	ReturnedAt sql.NullTime `json:"returned_at"`
	Status     string       `json:"status"`
	UserName   string       `json:"user_name"`
	BookTitle  string       `json:"book_title"`
}

func (q *Queries) ListLoansByUserWithDetails(ctx context.Context, arg ListLoansByUserWithDetailsParams) ([]ListLoansByUserWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listLoansByUserWithDetails, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLoansByUserWithDetailsRow{}
	for rows.Next() {
		var i ListLoansByUserWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Status,
			&i.UserName,
			&i.BookTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansWithDetails = `-- name: ListLoansWithDetails :many
SELECT
    l.id, l.user_id, l.book_id, l.borrowed_at, l.due_date, l.returned_at, l.status,
    u.name as user_name,
    b.title as book_title
FROM loans l
JOIN users u ON l.user_id = u.id
JOIN books b ON l.book_id = b.id
ORDER BY l.borrowed_at DESC
LIMIT $1 OFFSET $2
`

type ListLoansWithDetailsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListLoansWithDetailsRow struct {
	ID         uuid.UUID    `json:"id"`
	UserID     uuid.UUID    `json:"user_id"`
	BookID     uuid.UUID    `json:"book_id"`
	BorrowedAt time.Time    `json:"borrowed_at"`
	DueDate    time.Time    `json:"due_date"`
	ReturnedAt sql.NullTime `json:"returned_at"`
	Status     string       `json:"status"`
	UserName   string       `json:"user_name"`
	BookTitle  string       `json:"book_title"`
}

func (q *Queries) ListLoansWithDetails(ctx context.Context, arg ListLoansWithDetailsParams) ([]ListLoansWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listLoansWithDetails, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLoansWithDetailsRow{}
	for rows.Next() {
		var i ListLoansWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Status,
			&i.UserName,
			&i.BookTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLoan = `-- name: UpdateLoan :one
UPDATE loans
SET returned_at = $2, status = $3
WHERE id = $1
RETURNING id, user_id, book_id, borrowed_at, due_date, returned_at, status
`

type UpdateLoanParams struct {
	ID         uuid.UUID    `json:"id"`
	ReturnedAt sql.NullTime `json:"returned_at"`
	Status     string       `json:"status"`
}

func (q *Queries) UpdateLoan(ctx context.Context, arg UpdateLoanParams) (Loan, error) {
	row := q.db.QueryRowContext(ctx, updateLoan, arg.ID, arg.ReturnedAt, arg.Status)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BookID,
		&i.BorrowedAt,
		&i.DueDate,
		&i.ReturnedAt,
		&i.Status,
	)
	return i, err
}
